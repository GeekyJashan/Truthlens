{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState } from 'react';\nexport const useClaimAnalysis = () => {\n  _s();\n  const [isAnalyzing, setIsAnalyzing] = useState(false);\n  const [claimStats, setClaimStats] = useState({\n    total: 0,\n    true: 0,\n    false: 0,\n    inconclusive: 0\n  });\n  const analyzeContent = async content => {\n    setIsAnalyzing(true);\n    try {\n      const response = await fetch('http://127.0.0.1:8000/detect_and_verify_claims', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          text: content\n        })\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n\n      // Calculate stats\n      const newStats = {\n        total: data.metadata.total_claims,\n        true: data.verified_claims.filter(c => c.verification.verdict === 'TRUE' && c.verification.confidence === 'HIGH').length,\n        false: data.verified_claims.filter(c => c.verification.verdict === 'FALSE' && c.verification.confidence === 'HIGH').length,\n        inconclusive: data.verified_claims.filter(c => c.verification.verdict === 'INCONCLUSIVE' || c.verification.confidence !== 'HIGH').length\n      };\n      setClaimStats(newStats);\n\n      // Highlight claims in the content\n      let highlightedContent = content;\n      data.verified_claims.forEach(claim => {\n        const cleanClaim = claim.claim.replace(/^\\d+\\.\\s*\"|\"$/g, '').trim();\n        let color = 'bg-blue-500/20 text-blue-700 dark:text-blue-300'; // default for inconclusive/low confidence\n\n        if (claim.verification.confidence === 'HIGH') {\n          if (claim.verification.verdict === 'TRUE') {\n            color = 'bg-green-500/20 text-green-700 dark:text-green-300';\n          } else if (claim.verification.verdict === 'FALSE') {\n            color = 'bg-red-500/20 text-red-700 dark:text-red-300';\n          }\n        }\n        const sentenceRegex = new RegExp(`[^.!?]*${cleanClaim}[^.!?]*[.!?]`, 'gi');\n        highlightedContent = highlightedContent.replace(sentenceRegex, match => `<span class=\"px-1 rounded ${color}\" title=\"${claim.verification.explanation}\">${match}</span>`);\n      });\n      return {\n        content: content,\n        metadata: {\n          total_claims: data.metadata.total_claims,\n          successfully_verified: data.metadata.successfully_verified\n        },\n        verified_claims: data.verified_claims\n      };\n    } catch (error) {\n      console.error('Error analyzing content:', error);\n      throw error;\n    } finally {\n      setIsAnalyzing(false);\n    }\n  };\n  return {\n    analyzeContent,\n    isAnalyzing,\n    claimStats\n  };\n};\n_s(useClaimAnalysis, \"Hhy+EWuAnhDv9corvdIuXUp9/V0=\");","map":{"version":3,"names":["useState","useClaimAnalysis","_s","isAnalyzing","setIsAnalyzing","claimStats","setClaimStats","total","true","false","inconclusive","analyzeContent","content","response","fetch","method","headers","body","JSON","stringify","text","ok","Error","status","data","json","newStats","metadata","total_claims","verified_claims","filter","c","verification","verdict","confidence","length","highlightedContent","forEach","claim","cleanClaim","replace","trim","color","sentenceRegex","RegExp","match","explanation","successfully_verified","error","console"],"sources":["/Users/writesonic/Documents/major_project/truthlens/src/useClaimAnalysis.ts"],"sourcesContent":["import { useState } from 'react';\n\ninterface Claim {\n  claim: string;\n  verification: 'True' | 'False';\n}\n\n\ninterface Verification {\n  verdict: 'TRUE' | 'FALSE' | 'INCONCLUSIVE';\n  confidence: 'HIGH' | 'MEDIUM' | 'LOW';\n  explanation: string;\n  evidence: string;\n}\n\ninterface VerifiedClaim {\n  claim: string;\n  verification: Verification;\n}\n\ninterface ApiResponse {\n  status: string;\n  detected_claims: string[];\n  verified_claims: VerifiedClaim[];\n  metadata: {\n    total_claims: number;\n    successfully_verified: number;\n  };\n}\n\ninterface AnalysisResult {\n  content: string;\n  stats: {\n    total: number;\n    true: number;\n    false: number;\n    inconclusive: number;\n  };\n}\n\nexport const useClaimAnalysis = () => {\n  const [isAnalyzing, setIsAnalyzing] = useState(false);\n  const [claimStats, setClaimStats] = useState<AnalysisResult['stats']>({\n    total: 0,\n    true: 0,\n    false: 0,\n    inconclusive: 0\n  });\n\n  const analyzeContent = async (content: string) => {\n    setIsAnalyzing(true);\n    try {\n      const response = await fetch('http://127.0.0.1:8000/detect_and_verify_claims', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ text: content }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const data: ApiResponse = await response.json();\n      \n      // Calculate stats\n      const newStats = {\n        total: data.metadata.total_claims,\n        true: data.verified_claims.filter(c => c.verification.verdict === 'TRUE' && c.verification.confidence === 'HIGH').length,\n        false: data.verified_claims.filter(c => c.verification.verdict === 'FALSE' && c.verification.confidence === 'HIGH').length,\n        inconclusive: data.verified_claims.filter(c => \n          c.verification.verdict === 'INCONCLUSIVE' || \n          c.verification.confidence !== 'HIGH'\n        ).length\n      };\n      \n      setClaimStats(newStats);\n\n      // Highlight claims in the content\n      let highlightedContent = content;\n      data.verified_claims.forEach(claim => {\n        const cleanClaim = claim.claim.replace(/^\\d+\\.\\s*\"|\"$/g, '').trim();\n        let color = 'bg-blue-500/20 text-blue-700 dark:text-blue-300'; // default for inconclusive/low confidence\n\n        if (claim.verification.confidence === 'HIGH') {\n          if (claim.verification.verdict === 'TRUE') {\n            color = 'bg-green-500/20 text-green-700 dark:text-green-300';\n          } else if (claim.verification.verdict === 'FALSE') {\n            color = 'bg-red-500/20 text-red-700 dark:text-red-300';\n          }\n        }\n\n        const sentenceRegex = new RegExp(`[^.!?]*${cleanClaim}[^.!?]*[.!?]`, 'gi');\n        highlightedContent = highlightedContent.replace(\n          sentenceRegex,\n          (match) => `<span class=\"px-1 rounded ${color}\" title=\"${claim.verification.explanation}\">${match}</span>`\n        );\n      });\n\n      return {\n        content: content,\n        metadata: {\n          total_claims: data.metadata.total_claims,\n          successfully_verified: data.metadata.successfully_verified\n        },\n        verified_claims: data.verified_claims\n      };\n\n    } catch (error) {\n      console.error('Error analyzing content:', error);\n      throw error;\n    } finally {\n      setIsAnalyzing(false);\n    }\n  };\n\n  return { analyzeContent, isAnalyzing, claimStats };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}